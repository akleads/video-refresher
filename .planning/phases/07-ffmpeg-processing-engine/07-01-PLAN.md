---
phase: 07-ffmpeg-processing-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/db/schema.js
  - server/db/queries.js
  - server/lib/ffmpeg.js
  - server/lib/effects.js
autonomous: true

must_haves:
  truths:
    - "job_files table has columns for progress_percent, duration_seconds, ffmpeg_pid, and error"
    - "A new output_files table tracks each variation output (path, file_size, variation_index)"
    - "ffprobe can extract duration from an MP4 file and return it as a number"
    - "FFmpeg can be spawned with a filter string and progress callback fires with percentage values"
    - "generateUniqueEffects(N) returns N unique effect objects with rotation, brightness, contrast, saturation in v1 ranges"
  artifacts:
    - path: "server/lib/ffmpeg.js"
      provides: "FFmpeg spawn wrapper with progress parsing, ffprobe duration extraction"
      exports: ["spawnFFmpeg", "getVideoDuration"]
    - path: "server/lib/effects.js"
      provides: "Random effects generation matching v1 behavior"
      exports: ["generateUniqueEffects"]
    - path: "server/db/schema.js"
      provides: "Updated schema with progress columns, output_files table"
      contains: "output_files"
    - path: "server/db/queries.js"
      provides: "New prepared statements for progress updates and output file tracking"
      exports: ["createJobQueries"]
  key_links:
    - from: "server/lib/ffmpeg.js"
      to: "child_process.spawn"
      via: "spawn('ffmpeg', args) and spawn('ffprobe', args)"
      pattern: "spawn\\('ffmpeg'"
    - from: "server/lib/ffmpeg.js"
      to: "readline"
      via: "stderr line-by-line parsing for progress"
      pattern: "readline\\.createInterface"
---

<objective>
Create the foundation modules for Phase 7: database schema extensions for progress/output tracking, FFmpeg spawn wrapper with progress parsing, ffprobe duration extraction, and v1-compatible random effects generator.

Purpose: These are the building blocks that the processor and queue worker (Plan 07-02) will compose. Without schema columns for progress, there is nowhere to store it. Without the FFmpeg wrapper, there is no way to encode. Without effects, variations are not unique.

Output: Four modified/new files providing schema, queries, FFmpeg wrapper, and effects generator.
</objective>

<execution_context>
@/Users/alexkozhemiachenko/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexkozhemiachenko/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-ffmpeg-processing-engine/07-RESEARCH.md
@server/db/schema.js
@server/db/queries.js
@server/db/index.js
@server/lib/id.js
@server/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend database schema and queries for progress and output tracking</name>
  <files>server/db/schema.js, server/db/queries.js</files>
  <action>
  Modify `server/db/schema.js` to add columns to `job_files` and create a new `output_files` table:

  **job_files additions (ALTER TABLE with IF NOT EXISTS pattern):**
  - `progress_percent INTEGER NOT NULL DEFAULT 0` -- 0-100, updated during FFmpeg encoding
  - `duration_seconds REAL` -- filled by ffprobe before encoding, NULL if probe fails
  - `ffmpeg_pid INTEGER` -- current FFmpeg process PID, NULL when not encoding, used for recovery
  - `error TEXT` -- per-file error message if processing fails
  - `completed_variations INTEGER NOT NULL DEFAULT 0` -- count of finished variations for this file

  **New `output_files` table:**
  ```sql
  CREATE TABLE IF NOT EXISTS output_files (
    id TEXT PRIMARY KEY,
    job_id TEXT NOT NULL REFERENCES jobs(id) ON DELETE CASCADE,
    job_file_id TEXT NOT NULL REFERENCES job_files(id) ON DELETE CASCADE,
    variation_index INTEGER NOT NULL,
    output_path TEXT NOT NULL,
    file_size INTEGER,
    created_at TEXT NOT NULL DEFAULT (datetime('now'))
  );
  CREATE INDEX IF NOT EXISTS idx_output_files_job_id ON output_files(job_id);
  CREATE INDEX IF NOT EXISTS idx_output_files_job_file_id ON output_files(job_file_id);
  ```

  **Important:** Since SQLite does not support `ALTER TABLE ... ADD COLUMN IF NOT EXISTS`, use a migration pattern that catches the "duplicate column name" error or checks `PRAGMA table_info(job_files)` before adding. The simplest approach: wrap each ALTER TABLE in a try/catch in a `migrateSchema(db)` function called after `createTables(db)`. This is safe because `ALTER TABLE ADD COLUMN` is idempotent if the column already exists (it just errors).

  Modify `server/db/queries.js` to add these prepared statements to the returned object:

  ```javascript
  // Progress tracking
  updateFileProgress: db.prepare(
    `UPDATE job_files SET progress_percent = ?, updated_at = datetime('now') WHERE id = ?`
  ),
  updateFileStatus: db.prepare(
    `UPDATE job_files SET status = ?, updated_at = datetime('now') WHERE id = ?`
  ),
  updateFileDuration: db.prepare(
    `UPDATE job_files SET duration_seconds = ? WHERE id = ?`
  ),
  updateFilePid: db.prepare(
    `UPDATE job_files SET ffmpeg_pid = ? WHERE id = ?`
  ),
  updateFileError: db.prepare(
    `UPDATE job_files SET status = 'failed', error = ?, updated_at = datetime('now') WHERE id = ?`
  ),
  incrementFileVariations: db.prepare(
    `UPDATE job_files SET completed_variations = completed_variations + 1 WHERE id = ?`
  ),

  // Job status updates
  updateJobStatus: db.prepare(
    `UPDATE jobs SET status = ?, updated_at = datetime('now') WHERE id = ?`
  ),
  updateJobError: db.prepare(
    `UPDATE jobs SET status = 'failed', error = ?, updated_at = datetime('now') WHERE id = ?`
  ),

  // Output files
  insertOutputFile: db.prepare(
    `INSERT INTO output_files (id, job_id, job_file_id, variation_index, output_path, file_size)
     VALUES (?, ?, ?, ?, ?, ?)`
  ),
  getOutputFiles: db.prepare(
    `SELECT * FROM output_files WHERE job_id = ?`
  ),
  getOutputFilesByJobFile: db.prepare(
    `SELECT * FROM output_files WHERE job_file_id = ?`
  ),

  // Recovery queries
  getProcessingJobs: db.prepare(
    `SELECT * FROM jobs WHERE status = 'processing'`
  ),
  getFilesWithPid: db.prepare(
    `SELECT * FROM job_files WHERE ffmpeg_pid IS NOT NULL`
  ),
  clearFilePid: db.prepare(
    `UPDATE job_files SET ffmpeg_pid = NULL WHERE id = ?`
  ),
  getNextQueuedJob: db.prepare(
    `SELECT * FROM jobs WHERE status = 'queued' ORDER BY created_at ASC LIMIT 1`
  )
  ```

  Also add `updated_at` column to `job_files` if not already present (it is NOT in the Phase 6 schema -- check schema.js). Add it via the migration function.

  Do NOT change the existing `insertJob`, `insertJobFile`, `getJob`, `getJobFiles`, `listJobs` queries -- they must remain backward compatible.
  </action>
  <verify>
  Run `node -e "import('./server/db/index.js').then(m => { const db = m.initDatabase('./data/test-schema.db'); import('./server/db/queries.js').then(q => { const queries = q.createJobQueries(db); console.log('All queries prepared successfully'); console.log('Tables:', db.prepare(\"SELECT name FROM sqlite_master WHERE type='table'\").all()); db.close(); }); })"` from the project root. Should print all table names including `output_files` and "All queries prepared successfully" without errors. Clean up test db after.
  </verify>
  <done>
  Schema has progress_percent, duration_seconds, ffmpeg_pid, error, completed_variations, updated_at columns on job_files. output_files table exists with proper indexes. All new prepared statements compile without error. Existing queries unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create FFmpeg spawn wrapper and effects generator modules</name>
  <files>server/lib/ffmpeg.js, server/lib/effects.js</files>
  <action>
  Create `server/lib/ffmpeg.js` with two exported functions:

  **`getVideoDuration(filePath)`** -- Returns a Promise that resolves to duration in seconds (number).
  - Spawns `ffprobe -v quiet -print_format json -show_format <filePath>`
  - Collects stdout, parses JSON, extracts `data.format.duration` as parseFloat
  - On error or non-zero exit, returns 0 (not throw -- caller will use 0 as fallback meaning "no progress tracking")
  - Close stdout/stderr listeners in finally block

  **`spawnFFmpeg(inputPath, outputPath, filterString, onProgress, durationSeconds)`** -- Returns a Promise that resolves on success (exit code 0), rejects on failure. Also returns the child process reference so caller can store pid and kill if needed.

  Pattern: Return `{ process: ffmpegChild, promise: encodingPromise }` so caller can access `.process.pid` for SQLite tracking.

  Implementation details:
  - Args array matching v1 encoding exactly:
    ```
    ['-i', inputPath, '-vf', filterString, '-r', '29.97', '-b:v', '2000k', '-bufsize', '4000k', '-maxrate', '2500k', '-preset', 'ultrafast', '-crf', '23', '-threads', '4', '-pix_fmt', 'yuv420p', '-movflags', '+faststart', '-map_metadata', '-1', '-y', outputPath]
    ```
  - stdio: `['ignore', 'pipe', 'pipe']`
  - Parse stderr with `readline.createInterface({ input: ffmpegChild.stderr })`
  - On each line matching `/time=(\d{2}):(\d{2}):(\d{2}\.\d{2})/`, compute seconds and call `onProgress(Math.max(0, Math.min(100, Math.round((currentSeconds / durationSeconds) * 100))))` -- only if durationSeconds > 0
  - CRITICAL: Call `rl.close()` in both the 'close' and 'error' handlers to prevent FD leaks
  - Collect stderr lines into an array (last 20 lines) for error reporting -- if exit code !== 0, include last stderr lines in error message
  - Handle the case where durationSeconds is 0 or null: skip progress callbacks, still encode

  Create `server/lib/effects.js` with one exported function:

  **`generateUniqueEffects(count)`** -- Exact port from v1 app.js.
  - `randomInRange(min, max)` helper (not exported)
  - Same ranges: rotation 0.001-0.01, brightness -0.05 to 0.05, contrast 0.95-1.05, saturation 0.95-1.05
  - Same dedup logic with Set + JSON.stringify
  - Same maxAttempts = count * 100
  - Throws if cannot generate enough unique effects

  Also export a helper **`buildFilterString(effects)`** that takes a single effect object and returns the FFmpeg filter string:
  ```javascript
  export function buildFilterString(effects) {
    return `rotate=${effects.rotation}:fillcolor=black@0,eq=brightness=${effects.brightness}:contrast=${effects.contrast}:saturation=${effects.saturation}`;
  }
  ```

  Both files use ESM (`export`/`import`) consistent with the `"type": "module"` in package.json.
  </action>
  <verify>
  1. Run `node -e "import('./server/lib/effects.js').then(m => { const fx = m.generateUniqueEffects(5); console.log('Effects:', JSON.stringify(fx, null, 2)); console.log('Filter:', m.buildFilterString(fx[0])); console.log('Count:', fx.length); })"` -- should print 5 unique effects with rotation/brightness/contrast/saturation in expected ranges, and a filter string like `rotate=0.0045:fillcolor=black@0,eq=brightness=0.0123:contrast=1.0234:saturation=0.9876`.

  2. Run `node -e "import('./server/lib/ffmpeg.js').then(m => { console.log('getVideoDuration type:', typeof m.getVideoDuration); console.log('spawnFFmpeg type:', typeof m.spawnFFmpeg); })"` -- should print both as 'function'.

  3. If ffmpeg is installed locally: `node -e "import('./server/lib/ffmpeg.js').then(async m => { const d = await m.getVideoDuration('/dev/null'); console.log('Duration of /dev/null (expected 0):', d); })"` -- should return 0 (graceful failure for non-video input).
  </verify>
  <done>
  ffmpeg.js exports spawnFFmpeg (returns {process, promise}) and getVideoDuration. effects.js exports generateUniqueEffects and buildFilterString. Effect ranges match v1 exactly. Filter string format matches v1 exactly. All use ESM exports.
  </done>
</task>

</tasks>

<verification>
1. `node -e "..."` schema test creates DB with all new columns and tables
2. Effects generator produces unique effects in v1 ranges
3. FFmpeg wrapper exports correct function signatures
4. All files use ESM imports/exports consistent with package.json "type": "module"
5. No changes to existing Phase 6 queries (backward compatible)
</verification>

<success_criteria>
- Schema has 5 new columns on job_files + new output_files table with indexes
- 15+ new prepared statements in queries.js for progress, status, output, recovery
- ffmpeg.js provides spawn wrapper with progress parsing + ffprobe duration extraction
- effects.js generates unique effects matching v1 ranges and filter string format
- All modules import cleanly without runtime errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-ffmpeg-processing-engine/07-01-SUMMARY.md`
</output>
