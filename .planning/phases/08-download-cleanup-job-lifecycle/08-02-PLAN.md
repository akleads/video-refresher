---
phase: 08-download-cleanup-job-lifecycle
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - server/db/queries.js
  - server/lib/cleanup.js
  - server/index.js
autonomous: true

must_haves:
  truths:
    - "Jobs older than 24 hours are automatically deleted (files removed from volume, rows cleaned from SQLite)"
    - "When total stored output exceeds 85% of volume capacity, the oldest completed/failed jobs are evicted first"
    - "Cleanup daemon runs periodically (every 5 minutes) without manual intervention"
    - "Queued and processing jobs are never evicted or expired by the daemon"
    - "Cleanup daemon stops gracefully on server shutdown"
  artifacts:
    - path: "server/lib/cleanup.js"
      provides: "CleanupDaemon class with expiry and eviction logic"
      contains: "class CleanupDaemon"
    - path: "server/db/queries.js"
      provides: "getExpiredJobs, getEvictionCandidates, deleteJob queries"
      contains: "getExpiredJobs"
    - path: "server/index.js"
      provides: "CleanupDaemon initialization alongside worker"
      contains: "CleanupDaemon"
  key_links:
    - from: "server/lib/cleanup.js"
      to: "server/db/queries.js"
      via: "queries.getExpiredJobs, queries.getEvictionCandidates, queries.deleteJob"
      pattern: "this\\.queries\\.getExpiredJobs"
    - from: "server/lib/cleanup.js"
      to: "fs.statfsSync"
      via: "disk usage check for eviction threshold"
      pattern: "statfsSync"
    - from: "server/lib/cleanup.js"
      to: "fs.rmSync"
      via: "recursive deletion of job output directories"
      pattern: "rmSync.*recursive"
    - from: "server/index.js"
      to: "server/lib/cleanup.js"
      via: "import and start/stop lifecycle"
      pattern: "cleanup\\.start|cleanup\\.stop"
---

<objective>
Add cleanup daemon for automatic job expiry and storage-cap eviction.

Purpose: The 3GB Fly Volume needs lifecycle management -- expired jobs (24h+) must be purged automatically, and when storage fills up, the oldest results must be evicted to make room for new processing.
Output: CleanupDaemon class running every 5 minutes that enforces time-based expiry and 85%-threshold eviction, integrated into server startup and graceful shutdown.
</objective>

<execution_context>
@/Users/alexkozhemiachenko/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexkozhemiachenko/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-download-cleanup-job-lifecycle/08-RESEARCH.md

@server/db/queries.js
@server/db/schema.js
@server/lib/queue.js
@server/index.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add cleanup queries and create CleanupDaemon</name>
  <files>server/db/queries.js, server/lib/cleanup.js</files>
  <action>
    1. In `server/db/queries.js`, add three new prepared statements to the returned object in `createJobQueries`:

    ```javascript
    // Cleanup queries
    getExpiredJobs: db.prepare(`
      SELECT * FROM jobs
      WHERE expires_at < datetime('now')
        AND status IN ('completed', 'failed')
    `),

    getEvictionCandidates: db.prepare(`
      SELECT * FROM jobs
      WHERE status IN ('completed', 'failed')
      ORDER BY updated_at ASC
    `),

    deleteJob: db.prepare(`
      DELETE FROM jobs WHERE id = ?
    `),
    ```

    Note: deleteJob cascades to job_files and output_files thanks to ON DELETE CASCADE in the schema (and PRAGMA foreign_keys = ON in db/index.js).

    Also add a query for stuck queued jobs (recommended by RESEARCH.md open question 3):
    ```javascript
    getStuckQueuedJobs: db.prepare(`
      SELECT * FROM jobs
      WHERE status = 'queued'
        AND expires_at < datetime('now')
    `),
    ```

    2. Create `server/lib/cleanup.js` with a CleanupDaemon class:

    ```javascript
    import fs from 'node:fs';
    import path from 'node:path';
    ```

    Constants:
    - `CLEANUP_INTERVAL_MS = 5 * 60 * 1000` (5 minutes)
    - `EVICTION_THRESHOLD = 0.85` (85% usage triggers eviction)

    Class `CleanupDaemon`:
    - Constructor takes `(db, queries, dataDir)`. Store as instance properties. Initialize `this.timer = null`.
    - `start()`: Set `this.timer = setInterval(() => this.run(), CLEANUP_INTERVAL_MS)`. Call `this.timer.unref()` so it doesn't block process exit. Log "Cleanup daemon started (interval: 5m, eviction threshold: 85%)". Run once immediately via `this.run()`.
    - `stop()`: If `this.timer`, `clearInterval(this.timer)`, set to null. Log "Cleanup daemon stopped".
    - `run()`: Wrap in try/catch (log errors but never crash). Call `this.expireOldJobs()`, then `this.markStuckJobs()`, then `this.evictIfNeeded()`.

    `expireOldJobs()`:
    - Get expired jobs: `this.queries.getExpiredJobs.all()`
    - For each expired job:
      - Delete output files from disk FIRST: `fs.rmSync(path.join(this.dataDir, 'output', job.id), { recursive: true, force: true })`
      - Then delete DB row: `this.queries.deleteJob.run(job.id)` (CASCADE handles child rows)
      - Log: `console.log('Expired job ' + job.id)`
    - If any were expired, log count.

    `markStuckJobs()`:
    - Get stuck queued jobs: `this.queries.getStuckQueuedJobs.all()`
    - For each: mark as failed via `this.queries.updateJobError.run('Job expired while queued', job.id)`
    - These will be picked up by expireOldJobs on the NEXT cycle.

    `evictIfNeeded()`:
    - Get disk stats: `const stats = fs.statfsSync(this.dataDir)`
    - Calculate: `totalBytes = stats.blocks * stats.bsize`, `freeBytes = stats.bavail * stats.bsize`, `usedBytes = totalBytes - freeBytes`, `usageRatio = usedBytes / totalBytes`
    - If `usageRatio <= EVICTION_THRESHOLD`, return early.
    - Log: `console.log('Storage pressure: ' + Math.round(usageRatio * 100) + '% used, evicting oldest jobs...')`
    - Get candidates: `this.queries.getEvictionCandidates.all()`
    - For each candidate:
      - Delete output dir from disk: `fs.rmSync(path.join(this.dataDir, 'output', job.id), { recursive: true, force: true })`
      - Delete DB row: `this.queries.deleteJob.run(job.id)`
      - Log: `console.log('Evicted job ' + job.id + ' (storage pressure)')`
      - Recheck disk: call statfsSync again, recalculate usageRatio. If below threshold, break.
    - CRITICAL: Never evict 'queued' or 'processing' jobs -- the query already filters to completed/failed.

    Export: `export { CleanupDaemon }`
  </action>
  <verify>
    Run `cd /Users/alexkozhemiachenko/Downloads/Claude/video-refresher/server && node -e "import('./lib/cleanup.js').then(m => console.log('cleanup.js imports OK'))"` to verify the module parses.
    Run `node -e "import('./db/queries.js').then(m => console.log('queries.js imports OK'))"` to verify queries still parse.
  </verify>
  <done>
    - queries.js has getExpiredJobs, getEvictionCandidates, deleteJob, getStuckQueuedJobs prepared statements
    - cleanup.js exports CleanupDaemon class with start/stop/run/expireOldJobs/markStuckJobs/evictIfNeeded
    - Expiry checks `expires_at < datetime('now')` and status IN ('completed', 'failed')
    - Eviction uses fs.statfsSync with 85% threshold
    - Eviction only targets completed/failed jobs, ordered by oldest updated_at
    - Files deleted from disk BEFORE DB rows deleted
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate CleanupDaemon into server lifecycle</name>
  <files>server/index.js</files>
  <action>
    In `server/index.js`:

    1. Add import at top (alongside the other imports):
    ```javascript
    import { CleanupDaemon } from './lib/cleanup.js';
    ```

    2. After the worker creation line (`const worker = new JobQueueWorker(db, queries, OUTPUT_DIR)`), add:
    ```javascript
    const cleanup = new CleanupDaemon(db, queries, DATA_DIR);
    ```
    Note: Pass `DATA_DIR` (not OUTPUT_DIR) because `fs.statfsSync` needs the volume mount point to get accurate disk usage. The CleanupDaemon constructs output paths internally as `path.join(dataDir, 'output', jobId)`.

    3. In the `app.listen` callback, after `worker.start()`, add:
    ```javascript
    cleanup.start();
    ```

    4. In the `gracefulShutdown` function, after `worker.stop()` at the top, add:
    ```javascript
    cleanup.stop();
    ```

    That's it. The daemon runs alongside the worker, starts after recovery, and stops on shutdown.
  </action>
  <verify>
    Run `cd /Users/alexkozhemiachenko/Downloads/Claude/video-refresher/server && node -e "import('./index.js')" 2>&1 | head -5` -- should show server starting (will exit on its own or can Ctrl+C). The key check is no import errors.
    Alternatively, just verify the file parses: `node --check index.js`
  </verify>
  <done>
    - CleanupDaemon is imported in index.js
    - Daemon is instantiated with (db, queries, DATA_DIR)
    - Daemon starts in app.listen callback after worker.start()
    - Daemon stops in gracefulShutdown after worker.stop()
  </done>
</task>

</tasks>

<verification>
1. `cd /Users/alexkozhemiachenko/Downloads/Claude/video-refresher/server && node -e "import('./lib/cleanup.js').then(m => console.log('OK'))"` -- cleanup module loads
2. `node -e "import('./db/queries.js').then(m => console.log('OK'))"` -- queries module loads
3. `node --check index.js` -- server entry point parses
4. Grep for `getExpiredJobs` in queries.js to confirm cleanup queries exist
5. Grep for `CleanupDaemon` in index.js to confirm integration
6. Grep for `statfsSync` in cleanup.js to confirm disk usage check
7. Grep for `rmSync` in cleanup.js to confirm file deletion
</verification>

<success_criteria>
- CleanupDaemon runs every 5 minutes and expires jobs past 24 hours
- Eviction triggers at 85% volume usage, targeting oldest completed/failed jobs
- Stuck queued jobs (past expires_at) are marked failed before expiry
- Queued/processing jobs are never evicted
- Disk files deleted before DB rows (crash-safe ordering)
- Daemon integrates into server startup and graceful shutdown
- All modules parse without errors
</success_criteria>

<output>
After completion, create `.planning/phases/08-download-cleanup-job-lifecycle/08-02-SUMMARY.md`
</output>
