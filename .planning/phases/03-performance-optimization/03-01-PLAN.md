---
phase: 03-performance-optimization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [app.js]
autonomous: false

must_haves:
  truths:
    - "processVideo() uses ultrafast preset regardless of file size"
    - "processVideo() accepts optional preloadedBuffer parameter and skips file.arrayBuffer() when provided"
    - "loadVideoBuffer() reads file once and returns reusable Uint8Array"
    - "MEMFS cleanup conditionally keeps input file when cleanupInput is false"
    - "Processing time logged to console via performance.now() for each operation"
  artifacts:
    - path: "app.js"
      provides: "Optimized encoding settings, buffer reuse, performance timing"
      contains: "ultrafast"
  key_links:
    - from: "processVideo()"
      to: "loadVideoBuffer()"
      via: "optional preloadedBuffer parameter"
      pattern: "preloadedBuffer.*=.*null"
    - from: "handleFile()"
      to: "processVideo()"
      via: "backward-compatible call without buffer parameter"
      pattern: "await processVideo\\(file\\)"
---

<objective>
Optimize video processing speed by switching to ultrafast encoding preset and preparing buffer reuse infrastructure for Phase 4 batch processing.

Purpose: Phase 4 will process the same video 3-20 times with different effects. Without encoding optimization and buffer reuse, batch processing would be unnecessarily slow (reading 50-100MB file repeatedly, using slower presets). This plan lays the performance foundation.

Output: Modified app.js with unified ultrafast encoding, loadVideoBuffer() function, processVideo() accepting optional pre-loaded buffer, and performance timing.
</objective>

<execution_context>
@/Users/alexkozhemiachenko/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexkozhemiachenko/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-performance-optimization/03-RESEARCH.md
@app.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace tiered encoding with unified ultrafast preset and add buffer reuse infrastructure</name>
  <files>app.js</files>
  <action>
  Make these changes to app.js:

  **1. Add loadVideoBuffer() function** (add before processVideo function, around line 438):
  ```javascript
  async function loadVideoBuffer(file) {
      console.log('Loading video buffer...');
      const arrayBuffer = await file.arrayBuffer();
      return new Uint8Array(arrayBuffer);
  }
  ```

  **2. Modify processVideo() signature** to accept optional pre-loaded buffer and cleanup flag:
  Change `async function processVideo(file)` to:
  `async function processVideo(file, preloadedBuffer = null, cleanupInput = true)`

  **3. Modify buffer reading logic** (lines 462-464). Replace:
  ```javascript
  const arrayBuffer = await file.arrayBuffer();
  const uint8Array = new Uint8Array(arrayBuffer);
  ```
  With:
  ```javascript
  let uint8Array;
  if (preloadedBuffer) {
      uint8Array = preloadedBuffer;
      console.log('Reusing preloaded buffer');
  } else {
      const arrayBuffer = await file.arrayBuffer();
      uint8Array = new Uint8Array(arrayBuffer);
      console.log('Reading new buffer');
  }
  ```

  **4. Replace tiered encoding settings** (lines 491-527). Remove the entire if/else if/else block with fileSizeMB conditions and three separate encodingSettings arrays. Replace with a single unified block:
  ```javascript
  // Unified encoding: ultrafast preset for maximum speed (Phase 3 optimization)
  // CRF 23 maintains acceptable quality; bitrate cap prevents excessive file size
  const encodingSettings = [
      '-b:v', '2000k',
      '-bufsize', '4000k',
      '-maxrate', '2500k',
      '-preset', 'ultrafast',
      '-crf', '23',
  ];
  console.log('Using ultrafast encoding settings');
  ```
  Keep the `const fileSizeMB = file.size / (1024 * 1024);` line (line 494) ONLY if it's used elsewhere. Check: it's also used in the file size warning in handleFile (line 384), so the one in processVideo can be removed since it was only used for the tiered encoding. Actually, look carefully - `fileSizeMB` at line 494 is local to processVideo and only used for the encoding tier selection. Remove it along with the tiered block.

  **5. Add performance timing** around the FFmpeg exec call. Add before the exec call (around line 534):
  ```javascript
  const processingStartTime = performance.now();
  ```
  And after the exec call completes (after `console.log('FFmpeg processing completed');`):
  ```javascript
  const processingEndTime = performance.now();
  const processingTimeSec = ((processingEndTime - processingStartTime) / 1000).toFixed(2);
  console.log(`FFmpeg encoding completed in ${processingTimeSec}s`);
  ```

  **6. Modify MEMFS cleanup** (lines 601-607). Replace:
  ```javascript
  try {
      await ffmpeg.deleteFile(inputFileName);
      await ffmpeg.deleteFile(outputFileName);
  } catch (e) {
      console.warn('Cleanup warning:', e);
  }
  ```
  With:
  ```javascript
  try {
      await ffmpeg.deleteFile(outputFileName);
      if (cleanupInput) {
          await ffmpeg.deleteFile(inputFileName);
      }
  } catch (e) {
      console.warn('Cleanup warning:', e);
  }
  ```
  Note: Output file is ALWAYS deleted (already read into blob). Input file is kept when cleanupInput=false (for multi-variation reuse in Phase 4).

  **Backward compatibility check:** The call site in handleFile (line 417) is `await processVideo(file);` — this continues to work because preloadedBuffer defaults to null and cleanupInput defaults to true. No changes needed to handleFile.
  </action>
  <verify>
  1. Search app.js for 'ultrafast' — must appear exactly once in encodingSettings
  2. Search app.js for 'preset.*fast' or "preset', 'veryfast" — must NOT appear (old tiered presets removed)
  3. Search app.js for 'loadVideoBuffer' — function must exist
  4. Search app.js for 'preloadedBuffer' — parameter must exist in processVideo signature
  5. Search app.js for 'cleanupInput' — parameter must exist in processVideo signature and used in cleanup
  6. Search app.js for 'performance.now' — must appear for timing
  7. Verify `await processVideo(file)` call in handleFile is unchanged (backward compatible)
  </verify>
  <done>
  - processVideo uses ultrafast preset with CRF 23 and 2000k bitrate cap for all file sizes
  - loadVideoBuffer() function exists and returns Uint8Array from file
  - processVideo() accepts optional preloadedBuffer (defaults null) and cleanupInput (defaults true)
  - When preloadedBuffer provided, file.arrayBuffer() is skipped
  - When cleanupInput is false, input file remains in MEMFS for reuse
  - Processing time logged to console via performance.now()
  - handleFile() call site unchanged and backward compatible
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Encoding optimized to ultrafast preset with buffer reuse infrastructure ready for Phase 4. Performance timing added to console output.</what-built>
  <how-to-verify>
  1. Open the app in browser (python3 server.py or your usual method)
  2. Open DevTools Console (Cmd+Opt+J)
  3. Upload a test video (any MP4, ideally 10-30MB for quick testing)
  4. Watch console for:
     - "Using ultrafast encoding settings" (confirms unified preset)
     - "Reading new buffer" (confirms backward-compatible path, no preloadedBuffer)
     - "FFmpeg encoding completed in X.XXs" (confirms performance timing)
  5. Verify processed video plays correctly in preview
  6. Verify download works

  **Quality check:** Compare the processed video visually against what you've seen before. Ultrafast may produce slightly larger files but should look acceptable for social media use. If quality is noticeably degraded, note it — we can adjust CRF to 22 or switch to veryfast as compromise.

  **Optional baseline comparison:** If you have a previous processing time noted, compare against the new time logged in console. The improvement should be noticeable (30%+ faster encoding step).
  </how-to-verify>
  <resume-signal>Type "approved" or describe any quality/functionality issues</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:
1. app.js contains 'ultrafast' preset — no tiered encoding blocks remain
2. loadVideoBuffer() function exists in app.js
3. processVideo() has 3 parameters: file, preloadedBuffer=null, cleanupInput=true
4. handleFile() still calls processVideo(file) without extra args
5. Console shows encoding time via performance.now()
6. Video processes successfully end-to-end
7. No regression in existing functionality (upload, process, preview, download)
</verification>

<success_criteria>
1. Video encoding uses ultrafast preset by default (no file-size tiers)
2. Buffer reuse infrastructure ready: loadVideoBuffer() + preloadedBuffer parameter
3. MEMFS cleanup respects cleanupInput flag for future multi-variation reuse
4. Processing time visible in console for benchmarking
5. Human verified: video quality acceptable, functionality preserved
</success_criteria>

<output>
After completion, create `.planning/phases/03-performance-optimization/03-01-SUMMARY.md`
</output>
