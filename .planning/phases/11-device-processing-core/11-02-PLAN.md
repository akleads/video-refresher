---
phase: 11-device-processing-core
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - lib/device-processing/worker-pool.js
  - lib/device-processing/progress-tracker.js
autonomous: true

must_haves:
  truths:
    - "Worker pool manages 2 dedicated FFmpeg workers processing variations concurrently"
    - "Failed variations are retried once, then skipped with remaining variations continuing"
    - "Cancellation stops all remaining work and workers can be terminated cleanly"
    - "Progress tracker aggregates per-worker progress into overall and per-variation status"
  artifacts:
    - path: "lib/device-processing/worker-pool.js"
      provides: "Worker pool managing parallel FFmpeg Web Workers"
      min_lines: 100
    - path: "lib/device-processing/progress-tracker.js"
      provides: "Progress aggregation from multiple workers"
      min_lines: 40
  key_links:
    - from: "lib/device-processing/worker-pool.js"
      to: "lib/device-processing/ffmpeg-worker.js"
      via: "new Worker constructor"
      pattern: "new Worker.*ffmpeg-worker"
    - from: "lib/device-processing/worker-pool.js"
      to: "lib/device-processing/progress-tracker.js"
      via: "imports and calls progress tracker"
      pattern: "ProgressTracker|updateProgress"
---

<objective>
Create the worker pool manager and progress tracker that coordinate parallel video processing across multiple Web Workers.

Purpose: The worker pool orchestrates variation processing -- queuing jobs, distributing to available workers, handling retries and cancellation. The progress tracker aggregates status from concurrent workers into a single coherent progress state that the UI can consume. Together they bridge the FFmpeg worker (Plan 11-01) and the device progress view (Plan 11-03).

Output: Two modules in `lib/device-processing/` that manage concurrent processing and progress aggregation.
</objective>

<execution_context>
@/Users/alexkozhemiachenko/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexkozhemiachenko/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-device-processing-core/11-RESEARCH.md
@.planning/phases/11-device-processing-core/11-01-SUMMARY.md
@lib/device-processing/ffmpeg-worker.js
@lib/effects-shared.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create worker pool manager</name>
  <files>
    lib/device-processing/worker-pool.js
  </files>
  <action>
    Create `lib/device-processing/worker-pool.js` as an ES module:

    **Class: WorkerPool**

    Constructor(`workerCount = 2`):
    - Creates `workerCount` dedicated Web Workers from `./ffmpeg-worker.js` with `{ type: 'module' }`.
    - Initializes workers array with `{ worker, busy: false, initialized: false }` entries.
    - Maintains internal job queue (array of pending jobs).
    - Maintains `activeJobs` Map (workerIndex -> job object).
    - Maintains `cancelled` boolean flag (default false).
    - Maintains `completedResults` array for collecting successful outputs.
    - Maintains `onProgress` callback and `onVariationComplete` callback (set by caller).

    `async init()`:
    - Send `{ type: 'init' }` to each worker.
    - Wait for all workers to respond with `init-complete` or `init-error`.
    - Return `{ success: boolean, mode: 'multi-threaded'|'single-threaded', failedWorkers: number }`.
    - If ALL workers fail to init, throw error with message suggesting server processing.

    `async processVideo(videoFile, effects, onProgress, onVariationComplete)`:
    - Main entry point. Takes a File object, array of effect objects, and callbacks.
    - Read the File as ArrayBuffer: `const originalBuffer = await file.arrayBuffer()`. Store `originalBuffer` as instance property so retries can access it.
    - Store callbacks.
    - Create a job for each effect: `{ videoData: new Uint8Array(originalBuffer), effect, outputName: string, retries: 0, resolve, reject }`. Each job gets a fresh Uint8Array view from the stored originalBuffer.
    - Output names follow pattern: `${videoBaseName}/variation_${String(idx+1).padStart(3,'0')}.mp4`.
    - Queue all jobs and start processing.
    - Return a Promise that resolves when all variations are done (or cancelled), with `{ results: Array<{name, blob}>, completed: number, total: number, cancelled: boolean }`.

    `processNext()`:
    - Find an available (not busy, initialized) worker.
    - If none available or queue is empty or cancelled, return.
    - Dequeue next job, mark worker busy, store in activeJobs.
    - Send `{ type: 'process', videoData: job.videoData, effect: job.effect, outputName: job.outputName, totalDuration: job.totalDuration || 0 }` to worker. Transfer `job.videoData.buffer`.
    - Important: `videoData` was already a fresh copy (created when building the queue), so transferring it is safe.

    Worker message handler (`handleMessage(workerIdx, event)`):
    - `type: 'complete'`: Store result blob (`new Blob([event.data.result], { type: 'video/mp4' })`), call `onVariationComplete` callback, mark worker not busy, resolve job promise, call `processNext()`.
    - `type: 'progress'`: Forward to progress tracker via `onProgress` callback with worker index and progress value.
    - `type: 'error'`: If `job.retries < 1`, increment retries, re-create videoData from stored originalBuffer (`job.videoData = new Uint8Array(this.originalBuffer)`), push back to front of queue. Else, mark as failed (resolve with null instead of reject -- to not abort the batch), call `onVariationComplete` with failed status. Mark worker not busy, call `processNext()`.

    Worker error handler (`handleError(workerIdx, error)`):
    - Same retry logic as message error.

    `cancel()`:
    - Set `cancelled = true`.
    - Clear the queue.
    - For all active jobs, reject promises.
    - Don't terminate workers yet (caller decides).
    - Return `completedResults` so partial download is possible.

    `terminate()`:
    - Send `{ type: 'terminate' }` to each worker.
    - Small delay (100ms), then call `worker.terminate()` on each.
    - Clear all internal state.

    **Important design notes:**
    - Process one source video at a time (caller calls processVideo sequentially for each file).
    - Each call to processVideo creates fresh Uint8Array copies from the original ArrayBuffer for each job -- this prevents ArrayBuffer neutering issues when transferring to workers.
    - The pool doesn't import effects-shared.js -- effects are generated by the caller and passed in.
  </action>
  <verify>
    - `lib/device-processing/worker-pool.js` exists and exports `WorkerPool` class
    - Class has `init()`, `processVideo()`, `cancel()`, `terminate()` methods
    - Creates workers with `new Worker('./ffmpeg-worker.js', { type: 'module' })`
    - Retry logic: retries once then skips (does not reject/abort batch)
    - Cancel sets flag, clears queue, returns completed results
    - Fresh Uint8Array copy created for each queued job
  </verify>
  <done>
    Worker pool manages 2 concurrent FFmpeg workers, distributes variation processing jobs with a queue, retries failures once before skipping, supports cancellation with partial results, and prevents ArrayBuffer neutering through defensive copying.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create progress tracker</name>
  <files>
    lib/device-processing/progress-tracker.js
  </files>
  <action>
    Create `lib/device-processing/progress-tracker.js` as an ES module:

    **Class: ProgressTracker**

    Constructor(`totalVariations`, `onUpdate`):
    - `totalVariations`: Total number of variations being processed.
    - `onUpdate`: Callback function called with progress state object.
    - Internal state: `variationStates` Map (variationIndex -> { progress: 0-1, status: 'pending'|'processing'|'complete'|'failed' }).
    - Initialize all variations as pending.

    `updateVariationProgress(variationIndex, progress)`:
    - Update the progress value for the given variation (0-1 range).
    - Set status to 'processing' if not already.
    - Call `emitUpdate()`.

    `markComplete(variationIndex)`:
    - Set variation progress to 1.0, status to 'complete'.
    - Call `emitUpdate()`.

    `markFailed(variationIndex)`:
    - Set variation status to 'failed'.
    - Call `emitUpdate()`.

    `emitUpdate()`:
    - Compute overall progress: sum of all variation progresses / totalVariations.
    - Count completed, failed, processing, pending.
    - Find current active variation indices.
    - Call `onUpdate` with:
      ```
      {
        overall: number (0-1),
        completed: number,
        failed: number,
        total: number,
        currentVariation: number (1-indexed, first active variation),
        variationProgress: number (0-1, progress of the most recently updated variation)
      }
      ```

    `reset()`:
    - Reset all state for reuse with a new video.

    **Design:**
    - Pure state management -- no DOM, no workers. Just tracks numbers and calls a callback.
    - The device progress view (Plan 11-03) provides the onUpdate callback to render UI.
    - Worker pool calls updateVariationProgress/markComplete/markFailed as workers report.
  </action>
  <verify>
    - `lib/device-processing/progress-tracker.js` exists and exports `ProgressTracker` class
    - Constructor takes totalVariations and onUpdate callback
    - Has `updateVariationProgress`, `markComplete`, `markFailed`, `reset` methods
    - `emitUpdate` computes overall progress and calls onUpdate with structured state
    - No DOM manipulation, no worker references
  </verify>
  <done>
    Progress tracker aggregates per-variation progress into an overall state object, tracking completion/failure counts and current active variation, consumed by the UI layer via callback.
  </done>
</task>

</tasks>

<verification>
- `lib/device-processing/worker-pool.js` creates workers from `./ffmpeg-worker.js`
- Worker pool queues jobs, distributes to available workers, handles retry-once + skip
- `lib/device-processing/progress-tracker.js` aggregates multi-worker progress
- Cancellation returns partial results
- No circular dependencies between modules
</verification>

<success_criteria>
- Worker pool manages exactly 2 workers with job queue and concurrent processing
- Retry-once-then-skip failure handling ensures batch continues
- Cancellation is immediate (sets flag, clears queue, preserves completed)
- Progress tracker emits structured update objects with overall + per-variation status
- Both modules are pure ES modules with no DOM dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/11-device-processing-core/11-02-SUMMARY.md`
</output>
