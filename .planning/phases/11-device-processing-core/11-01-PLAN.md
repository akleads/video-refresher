---
phase: 11-device-processing-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - lib/device-processing/ffmpeg-worker.js
  - lib/device-processing/zip-generator.js
autonomous: true

must_haves:
  truths:
    - "FFmpeg.wasm loads in a Web Worker with multi-threaded core (falls back to single-threaded)"
    - "Worker processes a video file with an effect and returns the output as transferable ArrayBuffer"
    - "Worker reports progress percentage via postMessage during processing"
    - "ZIP generator bundles multiple blobs into a downloadable ZIP file organized by source video name"
  artifacts:
    - path: "lib/device-processing/ffmpeg-worker.js"
      provides: "Web Worker script for FFmpeg.wasm video processing"
      min_lines: 80
    - path: "lib/device-processing/zip-generator.js"
      provides: "client-zip wrapper for bundling processed videos"
      min_lines: 25
  key_links:
    - from: "lib/device-processing/ffmpeg-worker.js"
      to: "@ffmpeg/ffmpeg"
      via: "dynamic import from CDN via toBlobURL"
      pattern: "FFmpeg|toBlobURL"
    - from: "lib/device-processing/zip-generator.js"
      to: "client-zip"
      via: "ES module import from CDN"
      pattern: "downloadZip"
---

<objective>
Install client-side processing dependencies, create the FFmpeg Web Worker script and ZIP generation module.

Purpose: These are the foundational modules for device processing -- the worker does the actual video processing in a background thread, and the ZIP module bundles outputs for download. Both are standalone modules consumed by the worker pool (Plan 11-02) and progress view (Plan 11-03).

Output: Two new modules in `lib/device-processing/` plus npm dependencies installed.
</objective>

<execution_context>
@/Users/alexkozhemiachenko/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexkozhemiachenko/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-device-processing-core/11-RESEARCH.md
@lib/effects-shared.js
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create FFmpeg Web Worker</name>
  <files>
    package.json
    lib/device-processing/ffmpeg-worker.js
  </files>
  <action>
    1. Install npm dependencies: `npm install @ffmpeg/ffmpeg @ffmpeg/util client-zip`

    2. Create `lib/device-processing/ffmpeg-worker.js` as a dedicated Web Worker script:

    **Worker lifecycle:**
    - On `init` message: Load FFmpeg.wasm with multi-threaded core from CDN (unpkg `@ffmpeg/core-mt@0.12.6`), falling back to single-threaded core (`@ffmpeg/core@0.12.6`) if multi-thread fails. Use `toBlobURL()` to convert CDN URLs to blob URLs for CORS bypass. Post back `{ type: 'init-complete', mode: 'multi-threaded'|'single-threaded' }` or `{ type: 'init-error', error: string }`.
    - On `process` message (receives `{ videoData: Uint8Array, effect: object, outputName: string }`): Write input to FFmpeg virtual filesystem, build filter string using `buildFilterString()` imported from `../effects-shared.js` (note: relative import works in workers with `type: 'module'`), execute FFmpeg with `-i input.mp4 -vf {filterString} -preset ultrafast -c:a copy output.mp4`, read output, post back `{ type: 'complete', result: Uint8Array, outputName }` with transferable `[result.buffer]`. On error, post `{ type: 'error', error: string, outputName }`.
    - On `terminate` message: Call `ffmpeg.terminate()` for cleanup.

    **Progress reporting:**
    - Register `ffmpeg.on('log', callback)` to parse FFmpeg log output for `time=HH:MM:SS.ss` entries.
    - Compare parsed time against `totalDuration` (passed in process message) to compute percentage.
    - Post `{ type: 'progress', progress: number }` (0-1 range) on each meaningful update (throttle to avoid flooding -- only post when progress changes by >=2%).

    **Critical: ArrayBuffer neutering prevention.**
    - When writing input to FFmpeg: `await ffmpeg.writeFile('input.mp4', new Uint8Array(videoData))` -- create fresh Uint8Array because writeFile neuters the buffer via transferable postMessage internally.
    - After `ffmpeg.readFile('output.mp4')`, the result is a Uint8Array. Transfer it back to main thread with transferable for zero-copy.

    **Memory cleanup between variations:**
    - After reading output, call `await ffmpeg.deleteFile('input.mp4')` and `await ffmpeg.deleteFile('output.mp4')` to free FFmpeg virtual filesystem memory.

    **Import pattern:**
    - Import `{ FFmpeg }` from `@ffmpeg/ffmpeg` and `{ toBlobURL }` from `@ffmpeg/util` using CDN URLs in importScripts or dynamic import.
    - Since the project has no bundler (vanilla JS on Cloudflare Pages), use importmap or load from CDN. The recommended approach: use `import()` with CDN URLs from esm.sh or unpkg for ESM-compatible imports in the worker.
    - For `buildFilterString`, use relative import `import { buildFilterString } from '../effects-shared.js'` which works in module workers.
    - For `@ffmpeg/ffmpeg` and `@ffmpeg/util`, use: `const { FFmpeg } = await import('https://esm.sh/@ffmpeg/ffmpeg@0.12.15')` and `const { toBlobURL } = await import('https://esm.sh/@ffmpeg/util@0.12.2')` inside the init handler. This avoids needing importmaps.
  </action>
  <verify>
    - `lib/device-processing/ffmpeg-worker.js` exists and exports nothing (it's a worker script)
    - File handles `init`, `process`, and `terminate` message types
    - Contains `buildFilterString` import from effects-shared.js
    - Contains `ffmpeg.writeFile('input.mp4', new Uint8Array(videoData))` (buffer copy pattern)
    - Contains `ffmpeg.deleteFile` calls for cleanup
    - Contains progress parsing with `time=` regex
    - `package.json` has `@ffmpeg/ffmpeg`, `@ffmpeg/util`, and `client-zip` in dependencies
  </verify>
  <done>
    Web Worker script loads FFmpeg.wasm (multi-threaded with single-threaded fallback), processes videos with effects from shared module, reports progress via log parsing, handles memory cleanup between variations, and transfers results with zero-copy.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ZIP generator module</name>
  <files>
    lib/device-processing/zip-generator.js
  </files>
  <action>
    Create `lib/device-processing/zip-generator.js` using client-zip for streaming ZIP generation:

    **Exports:**
    - `generateZip(files)` -- Takes an array of `{ name: string, blob: Blob }` objects, returns a Blob of the ZIP file. Uses `downloadZip()` from client-zip.
    - `triggerDownload(blob, filename)` -- Creates a temporary anchor element, sets href to `URL.createObjectURL(blob)`, triggers click, then immediately revokes the URL to prevent memory leaks.

    **ZIP folder structure:**
    Match server output format. Files should be organized as:
    ```
    videoname/variation_001.mp4
    videoname/variation_002.mp4
    anotherVideo/variation_001.mp4
    ```
    The caller (worker-pool or progress view) will construct the `name` paths correctly -- this module just takes the array and zips it.

    **Import client-zip:**
    Since there's no bundler, use dynamic import from CDN: `const { downloadZip } = await import('https://esm.sh/client-zip@2')`.

    **Error handling:**
    - If downloadZip fails, throw with clear message "Failed to generate ZIP file"
    - If blob creation fails, throw with message
  </action>
  <verify>
    - `lib/device-processing/zip-generator.js` exists
    - Exports `generateZip` and `triggerDownload` functions
    - Uses `downloadZip` from client-zip CDN import
    - `triggerDownload` calls `URL.revokeObjectURL` after click
  </verify>
  <done>
    ZIP generator module bundles processed video blobs into a downloadable ZIP and handles blob URL lifecycle correctly to prevent memory leaks.
  </done>
</task>

</tasks>

<verification>
- `npm ls @ffmpeg/ffmpeg @ffmpeg/util client-zip` shows all three packages installed
- `lib/device-processing/ffmpeg-worker.js` is a valid ES module worker script
- `lib/device-processing/zip-generator.js` exports generateZip and triggerDownload
- No syntax errors in either file (check with `node --check` where applicable, or manual review)
</verification>

<success_criteria>
- FFmpeg Web Worker script handles init/process/terminate lifecycle with multi-threaded fallback
- Progress reporting uses log parsing with time= regex, throttled to 2% increments
- ArrayBuffer neutering is prevented with Uint8Array copy pattern
- ZIP generator uses client-zip from CDN with proper blob URL cleanup
- All npm dependencies installed
</success_criteria>

<output>
After completion, create `.planning/phases/11-device-processing-core/11-01-SUMMARY.md`
</output>
