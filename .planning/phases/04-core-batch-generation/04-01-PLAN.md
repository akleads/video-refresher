---
phase: 04-core-batch-generation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [app.js]
autonomous: true

must_haves:
  truths:
    - "Each variation receives unique random effect combination (no duplicate combos within batch)"
    - "Variations follow naming pattern: originalname_var1_abc123.mp4"
    - "processVideo() accepts effect parameters and variation index for batch use"
  artifacts:
    - path: "app.js"
      provides: "generateUniqueEffects, formatVariationFilename, extended processVideo"
      contains: "generateUniqueEffects"
    - path: "app.js"
      provides: "Variation filename formatting"
      contains: "formatVariationFilename"
  key_links:
    - from: "generateUniqueEffects()"
      to: "processVideo()"
      via: "effects parameter passed from batch orchestrator"
      pattern: "effects\\.rotation.*effects\\.brightness"
    - from: "formatVariationFilename()"
      to: "processVideo()"
      via: "variationIndex parameter generates output filename"
      pattern: "formatVariationFilename.*variationIndex"
---

<objective>
Build the batch logic foundations: unique effect combination generator, variation filename formatter, and extend processVideo() to accept per-variation effect parameters and variation index.

Purpose: These are the pure logic building blocks that the batch orchestrator (Plan 02) will call. Separating logic from UI/orchestration keeps each plan focused and under context budget.
Output: Three new functions in app.js (generateUniqueEffects, formatVariationFilename, randomInRange) and extended processVideo() signature.
</objective>

<execution_context>
@/Users/alexkozhemiachenko/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexkozhemiachenko/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-performance-optimization/03-01-SUMMARY.md
@.planning/phases/04-core-batch-generation/04-RESEARCH.md
@app.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add generateUniqueEffects(), formatVariationFilename(), and randomInRange() functions</name>
  <files>app.js</files>
  <action>
Add three new functions to app.js, placed after the existing `loadVideoBuffer()` function and before `processVideo()`:

1. **randomInRange(min, max)** — Returns a random float between min and max using Math.random().

2. **generateUniqueEffects(count)** — Generates `count` unique effect combination objects using Set-based duplicate detection:
   - Each effect object has properties in this exact order: { rotation, brightness, contrast, saturation }
   - Parameter ranges:
     - rotation: 0.001 to 0.01 (radians, subtle visual change)
     - brightness: -0.05 to 0.05
     - contrast: 0.95 to 1.05
     - saturation: 0.95 to 1.05
   - Round each value to 4 decimal places using parseFloat(val.toFixed(4))
   - Use JSON.stringify(effect) as Set key for duplicate detection
   - Use maxAttempts = count * 100 to prevent infinite loops
   - Throw Error if unable to generate enough unique combinations
   - Log generation stats: `Generated ${count} unique effect combinations in ${attempts} attempts`

3. **formatVariationFilename(originalName, variationIndex)** — Generates variation filename:
   - Strip .mp4 extension (case-insensitive): originalName.replace(/\.mp4$/i, '')
   - Call existing generateUniqueID() for 6-char hex ID
   - Return: `${baseName}_var${variationIndex}_${uniqueID}.mp4`
   - variationIndex is 1-based (1, 2, 3, ...)

IMPORTANT: Property order in effect objects MUST be consistent (rotation, brightness, contrast, saturation) — JSON.stringify serializes in insertion order, so inconsistent order breaks duplicate detection.

Do NOT modify processVideo() in this task — that is Task 2.
  </action>
  <verify>
Verify the three functions exist in app.js:
- Search for "function generateUniqueEffects" — must exist
- Search for "function formatVariationFilename" — must exist
- Search for "function randomInRange" — must exist
- Verify Set-based duplicate detection: search for "new Set()" within generateUniqueEffects
- Verify maxAttempts guard: search for "maxAttempts" within generateUniqueEffects
- Verify parameter ranges: rotation min 0.001, max 0.01; brightness min -0.05, max 0.05
- Verify toFixed(4) rounding applied to all four parameters
- Run `python3 -m http.server 8080` (or existing dev server) and load in browser — no console errors on page load
  </verify>
  <done>
Three functions (generateUniqueEffects, formatVariationFilename, randomInRange) exist in app.js with correct parameter ranges, Set-based dedup, maxAttempts safety, and consistent property ordering. Page loads without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend processVideo() to accept effects and variationIndex parameters</name>
  <files>app.js</files>
  <action>
Modify the existing processVideo() function signature and implementation:

1. **Extend signature** from:
   `async function processVideo(file, preloadedBuffer = null, cleanupInput = true)`
   to:
   `async function processVideo(file, preloadedBuffer = null, cleanupInput = true, effects = null, variationIndex = null)`

2. **Modify output filename generation** (around line 481-484). Replace the existing fixed filename generation:
   ```
   const fileName = file.name.replace(/\.mp4$/i, '');
   const uniqueID = generateUniqueID();
   const outputFileName = `${fileName}_${uniqueID}.mp4`;
   ```
   With conditional logic:
   ```
   let outputFileName;
   if (variationIndex !== null) {
       outputFileName = formatVariationFilename(file.name, variationIndex);
   } else {
       const fileName = file.name.replace(/\.mp4$/i, '');
       const uniqueID = generateUniqueID();
       outputFileName = `${fileName}_${uniqueID}.mp4`;
   }
   ```

3. **Modify video filter construction** (around line 519 where the hardcoded filter string is). Replace the hardcoded filter:
   `'-vf', 'rotate=0.00349,eq=brightness=0.01:contrast=1.01:saturation=1.01'`
   With conditional logic:
   ```
   let videoFilters;
   if (effects) {
       videoFilters = `rotate=${effects.rotation}:fillcolor=black@0,eq=brightness=${effects.brightness}:contrast=${effects.contrast}:saturation=${effects.saturation}`;
   } else {
       videoFilters = 'rotate=0.00349,eq=brightness=0.01:contrast=1.01:saturation=1.01';
   }
   ```
   Then use `videoFilters` in the ffmpeg.exec call: `'-vf', videoFilters`

4. **Extend return value** — After the existing processing completes (around line 583 where addProcessedVideo is called), add a return statement at the end of the function that returns metadata:
   ```
   return {
       filename: outputFileName,
       blob: blob,
       url: processedURL,
       effects: effects,
       size: blob.size
   };
   ```
   Note: The existing code already calls addProcessedVideo() and updateProgress() before this point — keep all that. Just add the return at the very end of the try block, after the MEMFS cleanup.

CRITICAL: Maintain full backward compatibility. When effects=null and variationIndex=null (the default), processVideo() MUST behave exactly as before — same hardcoded filter values, same filename format, same UI updates. The existing handleFile() call `await processVideo(file)` must continue to work unchanged.

Do NOT use `fillcolor=black@0` in the rotate filter for the default (non-batch) case — only add it when effects are provided. The existing default uses `rotate=0.00349` without fillcolor, keep it that way.
  </action>
  <verify>
1. Verify function signature: search for "async function processVideo(file, preloadedBuffer = null, cleanupInput = true, effects = null, variationIndex = null)"
2. Verify conditional filename: search for "formatVariationFilename" within processVideo
3. Verify conditional filter: search for "effects.rotation" and "effects.brightness" within processVideo
4. Verify backward compatibility: search for "rotate=0.00349" — the default filter must still exist
5. Verify return object: search for "filename: outputFileName" — return statement must exist
6. Load page in browser, upload a video, process it — existing single-file workflow must work identically (same filter values, same filename pattern, preview displays, download works)
  </verify>
  <done>
processVideo() accepts effects and variationIndex parameters. When provided, uses custom effects for video filter and formatVariationFilename for output name. When null (default), behaves exactly as before. Returns metadata object {filename, blob, url, effects, size}. Existing single-video workflow works unchanged.
  </done>
</task>

</tasks>

<verification>
1. Page loads without JavaScript errors
2. Existing single-video workflow works identically (upload, process, preview, download)
3. All three new functions exist: generateUniqueEffects, formatVariationFilename, randomInRange
4. processVideo() signature includes effects and variationIndex params with null defaults
5. processVideo() returns metadata object when complete
</verification>

<success_criteria>
- generateUniqueEffects(5) would produce 5 unique effect objects with rotation/brightness/contrast/saturation in correct ranges
- formatVariationFilename('test.mp4', 1) would produce 'test_var1_XXXXXX.mp4'
- processVideo(file) with no extra args works exactly as before (backward compatible)
- processVideo(file, buffer, false, effectObj, 3) uses custom effects and variation naming
- No regression in existing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/04-core-batch-generation/04-01-SUMMARY.md`
</output>
