---
phase: 02-memory-management
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified: [app.js]
autonomous: false

must_haves:
  truths:
    - "FFmpeg instance recovers automatically after OOM, abort, or WASM errors"
    - "User can process videos successfully after a prior FFmpeg failure"
    - "User can process same video 10 times consecutively without memory growth"
    - "All memory management from Plan 01 verified working end-to-end"
  artifacts:
    - path: "app.js"
      provides: "FFmpeg instance recovery logic in processVideo error handling"
      contains: "recoverFFmpeg"
  key_links:
    - from: "processVideo() catch block"
      to: "recoverFFmpeg()"
      via: "Error pattern matching triggers recovery"
      pattern: "corruptionIndicators"
    - from: "recoverFFmpeg()"
      to: "loadFFmpeg()"
      via: "Creates new FFmpeg instance and reloads"
      pattern: "ffmpeg = new FFmpeg"
---

<objective>
Add FFmpeg instance recovery on corruption-indicating errors and verify all Phase 2 memory management works end-to-end.

Purpose: Ensure FFmpeg can recover from failures (OOM, abort, WASM crashes) so batch processing in Phase 4 doesn't require page reload after errors.
Output: app.js with FFmpeg recovery logic; human-verified memory stability across 10 consecutive processing operations.
</objective>

<execution_context>
@/Users/alexkozhemiachenko/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexkozhemiachenko/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-memory-management/02-RESEARCH.md
@.planning/phases/02-memory-management/02-01-SUMMARY.md
@app.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add FFmpeg instance recovery on corruption-indicating errors</name>
  <files>app.js</files>
  <action>
Add an async function `recoverFFmpeg()` near the loadFFmpeg function (after it, before updateProgress). This function:

1. Logs: `console.warn('FFmpeg instance corrupted, recovering...');`
2. Sets `ffmpegLoaded = false;`
3. Creates new instance: `ffmpeg = new FFmpeg();`
4. Re-attaches both event handlers (progress and log) — copy the exact same handlers from loadFFmpeg:
   - `ffmpeg.on('progress', ...)` with the clamp logic
   - `ffmpeg.on('log', ...)`
5. Calls `await loadFFmpeg();` to reload the WASM core
6. Logs: `console.log('FFmpeg recovered successfully');`

Modify the catch block in processVideo() (around lines 461-473) to detect corruption and recover:

In the existing catch block, BEFORE the if/else chain that throws specific errors, add:

```javascript
// Check if FFmpeg instance needs recovery
const corruptionIndicators = [/abort/i, /OOM/i, /Out of Memory/i, /RuntimeError/i];
const needsRecovery = corruptionIndicators.some(p => p.test(error.message));
if (needsRecovery) {
    try {
        await recoverFFmpeg();
    } catch (recoveryError) {
        console.error('FFmpeg recovery failed:', recoveryError);
    }
}
```

This ensures the FFmpeg instance is in a clean state for the next operation, even though the current operation still fails. Do NOT retry the failed operation automatically — research recommends deferring retry logic to a later phase.

Also add the same recovery pattern to the outer catch in handleFile() (around line 334-348): after logging the error and before updating the status text, check if the error message matches corruption indicators and call recoverFFmpeg if so. This catches errors that propagate up from processVideo.

Wait — the error already propagates from processVideo's catch (which re-throws). So recovery in processVideo's catch is sufficient. The handleFile catch just displays the error message. No need to duplicate recovery logic there.
  </action>
  <verify>
Search app.js for `recoverFFmpeg` — should find function definition and at least one call. Search for `corruptionIndicators` — should find the array. Search for `ffmpegLoaded = false` — should find it in recoverFFmpeg. Verify loadFFmpeg is called inside recoverFFmpeg.
  </verify>
  <done>
After an FFmpeg processing error caused by OOM, abort, or WASM RuntimeError, the FFmpeg instance is automatically replaced with a fresh one and reloaded. The next processVideo call will work on a clean instance. No page reload required after FFmpeg failures.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete Phase 2 memory management:
- BlobURLRegistry centralizing all blob URL creation/revocation (Plan 01)
- Old original video blob URL revoked when new video uploaded (Plan 01)
- processedVideos bounded at 20 with eviction + blob URL cleanup (Plan 01)
- FFmpeg instance recovery after corruption errors (this plan)
- beforeunload safety net revoking all blob URLs (Plan 01)
  </what-built>
  <how-to-verify>
1. Start the local dev server: `python server.py` (or serve with COOP/COEP headers)
2. Open Chrome, navigate to the app
3. Open Chrome DevTools -> Performance Monitor (Cmd+Shift+P, search "Performance Monitor")
4. Watch "JS heap size" metric

**Test A: Memory stability (10 consecutive operations)**
- Upload a small test video (under 5MB for speed)
- Process it 10 times consecutively (upload same file 10 times)
- JS heap size should stabilize — NOT grow linearly with each iteration
- After processing, heap should be roughly similar to after first processing

**Test B: Original video blob URL revocation**
- Process a video, note it works
- Upload a different video — old original should be replaced
- Open DevTools Console — should see NO blob URL errors

**Test C: Processed videos list**
- Confirm processed videos appear in the list
- Confirm download buttons work for listed videos
- Videos should display and play correctly

**Test D: Basic functionality**
- Upload -> Process -> Preview -> Download all still work end-to-end
  </how-to-verify>
  <resume-signal>Type "approved" if memory is stable and all tests pass, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
After Task 1:
1. `grep -c 'recoverFFmpeg' app.js` should return at least 2 (definition + call)
2. `grep -c 'corruptionIndicators' app.js` should return at least 1
3. `grep -c 'ffmpegLoaded = false' app.js` should return at least 1 (in recoverFFmpeg)

After human verification:
4. 10 consecutive processing operations complete without linear memory growth
5. All existing functionality preserved (upload, process, preview, download)
</verification>

<success_criteria>
- FFmpeg instance auto-recovers after corruption errors (OOM, abort, RuntimeError)
- 10 consecutive video processing operations do not cause linear memory growth
- All blob URLs properly managed (original revoked on new upload, processed revoked on eviction)
- processedVideos bounded at 20 entries
- Download functionality works for all listed videos
- No regressions in existing upload -> process -> preview -> download flow
</success_criteria>

<output>
After completion, create `.planning/phases/02-memory-management/02-02-SUMMARY.md`
</output>
